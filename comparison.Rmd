---
title: "Comparing ZooMSS and ZooMizer"
author: "Patrick Sykes"
output:
  html_document:
    df_print: paged
place: Brisbane
---

# Introduction

Here we are trying to compare the original code ZooMSS model (version 2, Heneghan et al. 2020) with ZooMizer, an attempt at recreating it within the mizer package.

We start by initialising and running the two models.


```{r setup}
library(mizer)
library(Rcpp)

source("fZooMSS_Model.R") #source the model code
source("fZooMSS_Setup.R")
source("fZooMSS_CalculatePhytoParam.R")
#setwd("~/GitHub/ZooMizer/")
## Build environmental data
enviro <- readRDS("data/enviro_test20.RDS")
enviro_data <- fZooMSS_CalculatePhytoParam(enviro) # Calculate Phytoplankton Parameters
Groups <- read.csv("TestGroups.csv")

input_params <- enviro_data[15,]
input_params$dt <- 1
input_params$tmax <- 1
SaveTimeSteps <- TRUE

zoomsstest <- list()
zoomsstest$model$model_runtime <- system.time(
 zoomsstest <- fZooMSS_Model(input_params, Groups, SaveTimeSteps)
)
saveRDS(zoomsstest,"zoomssoutputdt1.rds")
zoomsstest <- readRDS("zoomssoutputdt1.rds")

input_params$tmaxx <- input_params$tmax

source("fZooMizer_run.R")
groups <- read.csv("data/TestGroups_mizer.csv")

zoomizertest <- fZooMizer_run(groups = groups, input = input_params)
```

Let's try and look at some comparisons...

# Initial values

We want to check that the initial setups were all the same. the `all.equal` function tests the 'near equality' of two objects, that is, whether the objects are equal to within a tolerance (by default the tolerance is 1.5e-8). It's appropriate to use that here to allow for small floating point errors introduced by unit conversions and converting back and forth between absolute and logged values.

```{r collapse=TRUE}

#weight vectors (i.e. size classes)
all.equal(zoomsstest$model$param$w, zoomizertest@params@w, check.attributes=FALSE)

all.equal(zoomsstest$model$param$w_phyto, zoomizertest@params@w_full[1:length(zoomsstest$model$param$w_phyto)],check.attributes=FALSE)

#abundances - phyto - dimensions time x weight
all.equal(zoomsstest$model$nPP ,zoomizertest@n_pp[1,1:length(zoomsstest$model$nPP)] * zoomizertest@params@dw_full[1:1:length(zoomsstest$model$nPP)], check.attributes=FALSE)

#abundances - zoo and fish. Note N is in dimensions time x weight x species
all.equal(zoomsstest$model$N[1,,] , zoomizertest@params@initial_n*matrix(zoomizertest@params@dw,nrow=zoomsstest$model$param$ngrps, ncol = length(zoomsstest$model$param$w), byrow=TRUE), check.attributes=FALSE)
#View(zoomsstest$model$N[1,,] / matrix(zoomsstest$model$param$w,nrow=zoomsstest$model$param$ngrps, ncol = length(zoomsstest$model$param$w), byrow=TRUE))
#View(zoomizertest@params@initial_n)

initialnsaved <- readRDS("data/initialn.RDS")
all.equal(zoomsstest$model$N[1,,] , initialnsaved * zoomizertest@params@dw, check.attributes=FALSE)

# quick check here: abundances after a time step?
all.equal(zoomsstest$model$N[2,,] , zoomizertest@n[2,,] * zoomizertest@params@dw, check.attributes=FALSE)
```

So we have that the size classes and initial abundance values (taking into account that ZooMSS is in absolute abundance and ZooMizer is in normalised abundance) are all in agreement. However, after a single time step they differ by a lot! Let's look into what might be doing this.

Recall the McKendrick-von Foerster equation

$$ \frac{\partial}{\partial t} N_i(w,t) = - \frac{\partial}{\partial w} (g_i(w,t) N_i(w,t)) - \mu_i(w,t)N_i(w,t), $$
where $g_i$ is growth (which is due to feeding) and $\mu_i$ is mortality (due to senescence and predation).

Let's look at the first term on the right-hand side: growth.

# Growth due to feeding

Trying with the actual growth matrices. Both Mizer and ZooMSS use g/yr as the units.

```{r}

param <- zoomsstest$model$param
model <- zoomsstest$model

    growth_multiplier <- colSums(model$N[1,,] * model$assim_eff) # 1 x n_sizes
    predation_multiplier <- model$N[1,,] * model$temp_eff # n_species x n_sizes
    #diffusion_multiplier <- colSums(N * (assim_eff^2)) # 1 x n_sizes

    ### DO GROWTH
    dynam_growthkernel <- model$dynam_growthkernel
    dim(dynam_growthkernel) <- c(model$param$ngrps*model$param$ngrid, model$param$ngrid)
    cs <- .colSums(growth_multiplier * t(dynam_growthkernel), m = model$param$ngrid, n = model$param$ngrps*model$param$ngrid)
    dim(cs) <- c(model$param$ngrps, model$param$ngrid)
    gg <- model$ingested_phyto + cs
    
zoomizererepro <- getERepro(zoomizertest@params) #all 0 as expected
zoomizerereprogrowth <- getEReproAndGrowth(zoomizertest@params)
zoomizeregrowth <- getEGrowth(zoomizertest@params)
all.equal(zoomizeregrowth, zoomizerereprogrowth) #should be equal since no energy goes to repro

all.equal(zoomizeregrowth[,2:178], gg[,1:177], check.attributes=FALSE) #it was really close earlier with zoomizeregrowth/w, now mizer's N is in 1/g so perhaps this is the right conversion?
```

Looking at the matrices, it's clearly not right. Though it's not completely clear whether the difference abundance units may be affecting this. Consider the function for growth:

$$ g_i(w,t) = \tau \sum_{j} 2.5 C_j V_i(w)\int_{w_p}^{w} \phi_i (w,w')N_j(w',t)w'dw' $$

The growth in ZooMSS is calculated from the search volume $V_i(w)$, prey size selectivity function $\phi_i(w,w')$, prey carbon content $C_j$ and temperature effect constant $\tau$. Let's look at these one at a time:

## Search volume

```{r}

#zoomss code
SearchVol <- matrix(NA, nrow = zoomsstest$model$param$ngrps, ncol = zoomsstest$model$param$ngrid)
for(i in 1:zoomsstest$model$param$ngrps){
        ### Search volume
    SearchVol[i,] <- (zoomsstest$model$param$Groups$SearchCoef[i])*(zoomsstest$model$param$w^(zoomsstest$model$param$Groups$SearchExp[i]))
    SearchVol[i, 10^(zoomsstest$model$param$Groups$Wmax[i]) < zoomsstest$model$param$w * (1 + 1e-06)] <- 0
    SearchVol[i, 10^(zoomsstest$model$param$Groups$W0[i]) > zoomsstest$model$param$w * (1 - 1e-06)] <- 0
}


all.equal(SearchVol, zoomizertest@params@search_vol, check.attributes=FALSE)

```

These are in agreement. How about feeding kernels?

```{r}

  
  gg_log_t_phyto <- ((param$w^-1) %*% t(param$w_phyto))/log(10) # Growth
  diet_log_t_phyto <- matrix(param$w_phyto, nrow = length(param$w), ncol = length(param$w_phyto), byrow = TRUE) # Diet/Ingestion

  # Predators are rows, dynam prey weights are columns
  gg_log_t_dynam <- ((param$w^-1) %*% t(param$w))/log(10) # Growth
  diet_log_t_dynam <- matrix(param$w, nrow = length(param$w), ncol = length(param$w), byrow = TRUE) # Diet/ingestion

  ### PREDATION KERNELS FOR PHYTOPLANKTON SPECTRUM AND DYNAMIC SPECTRUM
  phyto_pred_weight_matrix <- matrix(param$w, nrow = param$ngrid, ncol = param$ngridPP)
  dynam_pred_weight_matrix <- matrix(param$w, nrow = param$ngrid, ncol = param$ngrid)
  phyto_prey_weight_matrix <- matrix(param$w_phyto, nrow = param$ngrid, ncol = param$ngridPP, byrow = TRUE)
  dynam_prey_weight_matrix <- matrix(param$w, nrow = param$ngrid, ncol = param$ngrid, byrow = TRUE)

  ## Search Volume storage
  SearchVol <- matrix(NA, nrow = param$ngrps, ncol = param$ngrid) # Search volume

   ### Q10 OF 2 FOR ALL ZOO AND FISH
  temp_zoo <- rep(2.^((param$sst - 30)/10), param$num_zoo) # exp(23.93 - 0.59/(8.62e-05*(273+environ$sst)))
  temp_fish <- rep(2.^((param$sst - 30)/10), param$num_fish)
  temp_eff <- matrix(c(temp_zoo, temp_fish), nrow = param$ngrps, ncol = param$ngrid)

  
  phyto_predkernel <- array(0, dim=c(param$ngrps,param$ngrid,param$ngridPP))
  dynam_predkernel <- array(0, dim=c(param$ngrps,param$ngrid,param$ngrid))
  #### CALCULATES CONSTANT BITS OF THE MODEL FUNCTIONS FOR EACH GROUP
  for(i in 1:param$ngrps){
    ## Senescence mortality
    if(i < 10){
      model$M_sb[i,] <- param$ZSpre*(param$w/(10^(param$Groups$Wmat[i])))^param$ZSexp
      model$M_sb[i, 10^(param$Groups$Wmax[i]) < param$w] <- 0
      model$M_sb[i, 10^(param$Groups$Wmat[i]) > param$w] <- 0
    }

    if(i > 9){
      model$M_sb[i,] <- 0.1*param$ZSpre*(param$w/(10^(param$Groups$Wmat[i])))^param$ZSexp
      model$M_sb[i, 10^(param$Groups$Wmax[i]) < param$w] <- 0
      model$M_sb[i, 10^(param$Groups$Wmat[i]) > param$w] <- 0
    }

    ### Search volume
    SearchVol[i,] <- (param$Groups$SearchCoef[i])*(param$w^(param$Groups$SearchExp[i]))
    SearchVol[i, 10^(zoomsstest$model$param$Groups$Wmax[i]) < zoomsstest$model$param$w * (1 + 1e-06)] <- 0
    SearchVol[i, 10^(zoomsstest$model$param$Groups$W0[i]) > zoomsstest$model$param$w * (1 - 1e-06)] <- 0

    ### Predation Kernels
    if(is.na(param$Groups$PPMRscale[i]) == FALSE){ # If group has an m-value (zooplankton)
      # Calculate PPMR for zooplankton, which changes according to body-size (Wirtz, 2012)
      D.z <- 2*(3*param$w*1e12/(4*pi))^(1/3) # convert body mass g to ESD (um)
      betas <- (exp(0.02*log(D.z)^2 - param$Groups$PPMRscale[i] + 1.832))^3 # Wirtz's equation
      beta_mat_phyto <- matrix(betas, nrow = param$ngrid, ncol = param$ngridPP)
      beta_mat_dynam <- matrix(betas, nrow = param$ngrid, ncol = param$ngrid)

      # Calculate feeding kernels
      phyto_predkernel[i,,] <- exp(-0.5*(log((beta_mat_phyto*phyto_prey_weight_matrix)/
                                            phyto_pred_weight_matrix)/param$Groups$FeedWidth[i])^2)/
        sqrt(2*pi*param$Groups$FeedWidth[i]^2)
      dynam_predkernel[i,,] <- exp(-0.5*(log((beta_mat_dynam*dynam_prey_weight_matrix)/
                                            dynam_pred_weight_matrix)/param$Groups$FeedWidth[i])^2)/
        sqrt(2*pi*param$Groups$FeedWidth[i]^2)

      # The feeding kernal of filter feeders is not expected to change much with increasing size so we fix it here

      # if (param$fixed_filterPPMR == TRUE){
        if(i == 3){
          phyto_predkernel[i,,] <- matrix(phyto_predkernel[i,44,], nrow = param$ngrid, ncol = param$ngridPP, byrow = TRUE)
          dynam_predkernel[i,,] <- matrix(dynam_predkernel[i,44,], nrow = param$ngrid, ncol = param$ngrid, byrow = TRUE)
        }
        if(i == 8){
          phyto_predkernel[i,,] <- matrix(phyto_predkernel[i,61,], nrow = param$ngrid, ncol = param$ngridPP, byrow = TRUE)
          dynam_predkernel[i,,] <- matrix(dynam_predkernel[i,61,], nrow = param$ngrid, ncol = param$ngrid, byrow = TRUE)
        }
      # }

    } else { # If group does not have an m-value (fish)
      beta_mat_phyto <- matrix(param$Groups$PPMR[i], nrow = param$ngrid, ncol = param$ngridPP)
      beta_mat_dynam <- matrix(param$Groups$PPMR[i], nrow = param$ngrid, ncol = param$ngrid)

      # Calculate feeding kernels
      phyto_predkernel[i,,] <- exp(-0.5*(log((beta_mat_phyto*phyto_prey_weight_matrix)/
                                            phyto_pred_weight_matrix)/param$Groups$FeedWidth[i])^2)/
        sqrt(2*pi*param$Groups$FeedWidth[i]^2)
      dynam_predkernel[i,,] <- exp(-0.5*(log((beta_mat_dynam*dynam_prey_weight_matrix)/
                                            dynam_pred_weight_matrix)/param$Groups$FeedWidth[i])^2)/
        sqrt(2*pi*param$Groups$FeedWidth[i]^2)
      
    }
    
}

  zoomizerpredkernel <- getPredKernel(zoomizertest@params)
  dim(zoomizerpredkernel)
#all.equal(sp_dynam_predkernel[7,,],zoomizerpredkernel[7,,(216-178+1):216], check.attributes=FALSE) # different dimensions - how to compare?
  
  zoomizerdiet <- getDiet(zoomizertest@params, proportion = FALSE) #rowSums(sweep(params@pred_kernel, 3, params@dw_full * params@w_full * n_pp, "*"), dims = 2)
  #zoomssgrid[[1]]
  dim(zoomizerdiet)
  #dimnames(zoomizerdiet)
  #zoomizerdiet[,,13] #rowSums(sweep(params@pred_kernel, 3, params@dw_full * params@w_full * n_pp, "*"), dims = 2)
  dim(zoomsstest$model$phyto_dietkernel)
  
all.equal(zoomsstest$model$phyto_dietkernel[1,2,1],zoomsstest$model$phyto_dietkernel[1,2,2]) #sanity check

dim(phyto_predkernel)
dim(zoomizerpredkernel)



#comparing phytoplankton predation kernels
all.equal(phyto_predkernel[,,], zoomizerpredkernel[,,1:71], check.attributes=FALSE) #TRUE  

all.equal(phyto_predkernel[1,,], zoomizerpredkernel[1,,1:71], check.attributes=FALSE)   #TRUE  Flagellates 
all.equal(phyto_predkernel[2,,], zoomizerpredkernel[2,,1:71], check.attributes=FALSE)   #TRUE  Ciliates    
all.equal(phyto_predkernel[3,,], zoomizerpredkernel[3,,1:71], check.attributes=FALSE)   #TRUE  Larvaceans  
all.equal(phyto_predkernel[4,,], zoomizerpredkernel[4,,1:71], check.attributes=FALSE)   #TRUE  OmniCopepods
all.equal(phyto_predkernel[5,,], zoomizerpredkernel[5,,1:71], check.attributes=FALSE)   #TRUE  CarnCopepods
all.equal(phyto_predkernel[6,,], zoomizerpredkernel[6,,1:71], check.attributes=FALSE)   #TRUE  Euphausiids
all.equal(phyto_predkernel[7,,], zoomizerpredkernel[7,,1:71], check.attributes=FALSE)   #TRUE  Chaetognaths
all.equal(phyto_predkernel[8,,], zoomizerpredkernel[8,,1:71], check.attributes=FALSE)   #TRUE  Salps
all.equal(phyto_predkernel[9,,], zoomizerpredkernel[9,,1:71], check.attributes=FALSE)   #TRUE  Jellyfish
all.equal(phyto_predkernel[10,,], zoomizerpredkernel[10,,1:71], check.attributes=FALSE) #TRUE  Fish_Small
all.equal(phyto_predkernel[11,,], zoomizerpredkernel[11,,1:71], check.attributes=FALSE) #TRUE  Fish_Med
all.equal(phyto_predkernel[12,,], zoomizerpredkernel[12,,1:71], check.attributes=FALSE) #TRUE  Fish_Large

#comparing zoo/fish predation kernels
dim(dynam_predkernel)
all.equal(dynam_predkernel[,,], zoomizerpredkernel[,,39:216], check.attributes=FALSE)

all.equal(dynam_predkernel[1,,], zoomizerpredkernel[1,,39:216], check.attributes=FALSE)   #TRUE  Flagellates 
all.equal(dynam_predkernel[2,,], zoomizerpredkernel[2,,39:216], check.attributes=FALSE)   #TRUE  Ciliates
all.equal(dynam_predkernel[3,,], zoomizerpredkernel[3,,39:216], check.attributes=FALSE)   #TRUE  Larvaceans  
all.equal(dynam_predkernel[4,,], zoomizerpredkernel[4,,39:216], check.attributes=FALSE)   #TRUE  OmniCopepods
all.equal(dynam_predkernel[5,,], zoomizerpredkernel[5,,39:216], check.attributes=FALSE)   #TRUE  CarnCopepods
all.equal(dynam_predkernel[6,,], zoomizerpredkernel[6,,39:216], check.attributes=FALSE)   #TRUE  Euphausiids
all.equal(dynam_predkernel[7,,], zoomizerpredkernel[7,,39:216], check.attributes=FALSE)   #TRUE  Chaetognaths
all.equal(dynam_predkernel[8,,], zoomizerpredkernel[8,,39:216], check.attributes=FALSE)   #TRUE  Salps
all.equal(dynam_predkernel[9,,], zoomizerpredkernel[9,,39:216], check.attributes=FALSE)   #TRUE  Jellyfish
all.equal(dynam_predkernel[10,,], zoomizerpredkernel[10,,39:216], check.attributes=FALSE) #TRUE  Fish_Small
all.equal(dynam_predkernel[11,,], zoomizerpredkernel[11,,39:216], check.attributes=FALSE) #TRUE  Fish_Med
all.equal(dynam_predkernel[12,,], zoomizerpredkernel[12,,39:216], check.attributes=FALSE) #TRUE  Fish_Large
  
```

It looks like the difference may be in the different methods being used: ZooMSS does its numerical integration over log(weight) unlike Mizer, which does it over absolute weight. The conversion for this is given by arrays `dynam_growthkernel` and `phyto_growthkernel` and related helper arrays `gg_log_t_dynam` etc. These are what I will look at next...


# Mortality

Do the mortality rates agree?

```{r}


# View(zoomsstest$model$M_sb)
# View(zoomizertest@params@mu_b)
all.equal(zoomsstest$model$M_sb, zoomizertest@params@mu_b, check.attributes=FALSE)

```
